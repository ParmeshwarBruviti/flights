type Airline {
  code: String!
  name: String!
  country: String!
}

type Airport {
  code: String!
  name: String!
  country: String!
  city: String!
}

# type Flight {
#   flightNumber: String!
#   price: Int!
# }

# type Route {
#   code: String!
# }

# type RouteDetails {
#   stopsCount: Int!
# }

# type Stop {
#   stop: [String!]!
#   flights: [String!]!
# }

# type Flights {
#   search(from: String, to: String, date: String): [Temp] @cypher(statement: """
#       MATCH (a:Airport), (b:Airport)
#       WHERE a.city = $from AND b.city = $to
#       WITH distance(point({ latitude: AVG(a.location.latitude), longitude: AVG(a.location.longitude) }),
#       point({ latitude: AVG(b.location.latitude), longitude: AVG(b.location.longitude) })) / 1000 * 1.25 as max_distance
#       MATCH p = ((a:Airport)-[:FLIES_TO*1..3]->(b:Airport))
#       WHERE a.city = $from AND b.city = $to AND apoc.coll.sum([x IN relationships(p) | x.distance ]) <= max_distance AND SIZE(apoc.coll.duplicates(nodes(p))) = 0
#       WITH nodes(p) as stops
#       UNWIND apoc.coll.pairsMin(stops) as stop
#       CALL apoc.cypher.run('MATCH (ad:AirportDay { code: $' + 'adcode })-[:' + stop[0].code + '_FLIGHT]->(f:Flight)-[:' + stop[0].code + '_FLIGHT]->(bd:AirportDay { code: $' + 'bdcode }) RETURN f',
#       { adcode: stop[0].code + '_' + $date, bdcode: stop[1].code + '_' + $date }) yield value
#       WITH stops, stop, collect(distinct value.f) as flights
#       RETURN { a: [x IN stop | { code: x.code }] }
#       """
#       )
# }

# type Temp {
#   a: [Airport]
# }

type Query {

  # CitySearch(city: String): [Route]
  #   @cypher(
  #     statement: """
  #     CALL apoc.cypher.run('MATCH (a:Airport) WHERE a.city = $c RETURN a', { c: $city }) yield value
  #     WITH value.a as value
  #     RETURN value { .code, .name, .city, .country }
  #     """
  #   )

  # FlightsSearch(from: String, to: String, date: String): [Temp]
  #   @cypher(
  #     statement: """
  #     MATCH (a:Airport), (b:Airport)
  #     WHERE a.city = $from AND b.city = $to
  #     WITH distance(point({ latitude: AVG(a.location.latitude), longitude: AVG(a.location.longitude) }),
  #     point({ latitude: AVG(b.location.latitude), longitude: AVG(b.location.longitude) })) / 1000 * 1.25 as max_distance
  #     MATCH p = ((a:Airport)-[:FLIES_TO*1..3]->(b:Airport))
  #     WHERE a.city = $from AND b.city = $to AND apoc.coll.sum([x IN relationships(p) | x.distance ]) <= max_distance AND SIZE(apoc.coll.duplicates(nodes(p))) = 0
  #     WITH nodes(p) as stops
  #     UNWIND apoc.coll.pairsMin(stops) as stop
  #     CALL apoc.cypher.run('MATCH (ad:AirportDay { code: $' + 'adcode })-[:' + stop[0].code + '_FLIGHT]->(f:Flight)-[:' + stop[0].code + '_FLIGHT]->(bd:AirportDay { code: $' + 'bdcode }) RETURN f',
  #     { adcode: stop[0].code + '_' + $date, bdcode: stop[1].code + '_' + $date }) yield value
  #     WITH stops, stop, collect(distinct value.f) as flights
  #     RETURN { a: [x IN stop | { code: x.code }] }
  #     """
  #   )
# route: [x IN stops WHERE x IN NOT NULL | { name: x.name, code: x.code, city: x.city, country: x.country }],
  # FlightsSearch(a: String, b: String, date: String): [FlightsSearchResult]
  #   @cypher(
  #     statement:
  #     """
  #     MATCH (a:Airport { city: $a }), (b:Airport { city: $b })
  #     WITH distance(point({ latitude: AVG(a.location.latitude), longitude: AVG(a.location.longitude) }),
  #     point({ latitude: AVG(b.location.latitude), longitude: AVG(b.location.longitude) })) / 1000 * 1.25 as max_distance
  #     MATCH p = ((:Airport { city: a.city })-[:FLIES_TO*1..2]->(:Airport { city: b.city }))
  #     WHERE apoc.coll.sum([x IN relationships(p) | x.distance ]) <= max_distance AND SIZE(apoc.coll.duplicates(nodes(p))) = 0
  #     WITH nodes(p) as stops
  #     UNWIND apoc.coll.pairsMin(stops) as stop
  #     CALL apoc.cypher.run('MATCH (ad:AirportDay { code: $adcode })-[:' + stop[0].code + '_FLIGHT]->(f:Flight)-[:' + stop[0].code + '_FLIGHT]->(bd:AirportDay { code: $bdcode }) RETURN f',
  #     { adcode: stop[0].code + '_' + $date, bdcode: stop[1].code + '_' + $date }) yield value
  #     WITH stops, stop, collect(distinct value) as flights
  #     RETURN [x IN stops | x { .name, .code, .city, .country }]
  #     """
  #   )
}
